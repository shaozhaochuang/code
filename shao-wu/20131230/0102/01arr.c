#include <stdio.h>
#include <stdlib.h>

int main(void)
{
	int a[][2] = {1,2,3,4,5,6};
	printf("a = %p\n", a); //

	printf("size a = %d\n", sizeof(a));

	printf("定义指向数组首元素的指针：\n");
	//int (*p1)[2] = a; //也可以按下面的赋值
	int (*p1)[2] = &a[0];
	printf("p1 = %p\n", p1);
	p1++;
	printf("p1 = %p\n", p1);
	
	printf("定义指向整个数组的指针：\n");
	int (*p2)[3][2] = &a;
	printf("p2 = %p\n", p2);
	p2++;
	printf("p2 = %p\n", p2);
	printf("&a[2][1] = %p\n", &a[2][1]);

	printf("定义指向第0行第1列的元素的指针：\n");
	//int *p3 = a[0] + 1; //或者按下面方式初始化
	int *p3 = *a + 1;
	printf("p3 = %p\n", p3);
	p3++;
	printf("p3 = %p\n", p3);

	//如果某变量要充当左值，必须：1、它表示内存中的一个地址；2、它可以被修改。
	//如果左值作为右值使用（放在赋值号右边），那么使用的是它在内存中的值
	//不能充当左值的右值，是因为该值仅仅表示一个值，而不表示内存中一个地址。

	//数组元素在内存中是连续存放的，数组名在做右值时，表示的是指向数组首元素的指针。
	//数组名只有在：1、作为sizeof的操作数，2、对数组名取&操作时，才使用的是数组本身的类型。在其他情况下都会转化为指针来使用。

	//a++; //左值不能执行类似++的操作，因为左值表示的是内存中的一个确定的地址，不能被改变。

	//int (*ps)[2] = a++; //error, 同上
	int (*ps)[2] = a; //a此时充当右值，使用的是a作为左值时它所在的内存中保存的值

	int (*ps2)[2] = a + 1;

	int *pp = malloc(10); //在C中，void *类型可以赋值给任何类型的指针

	return 0;
}
